# ============================================================================
# CI Pipeline - Build and Deploy to Code Engine
# ============================================================================
# This workflow automatically builds, tests, and deploys the application to
# IBM Cloud Code Engine when code is pushed to the main branch.
#
# Prerequisites:
# 1. Dockerfile in repository root
# 2. GitHub Secrets configured: IBMCLOUD_API_KEY
# 3. GitHub Variables configured: IBMCLOUD_REGION, ICR_REGION, ICR_NAMESPACE,
#    RESOURCE_GROUP, PROJECT_NAME, APP_NAME, IMAGE_NAME
# 4. Code Engine project and ICR namespace created in IBM Cloud
# ============================================================================

name: Build and Deploy to Code Engine

# Trigger this workflow on push to main branch or manual dispatch
on:
  workflow_dispatch:  # Allows manual triggering from GitHub Actions UI
  push:
    branches: [ "main" ]  # Automatically runs on push to main

# Environment variables available to all jobs and steps in this workflow
env:
  GITHUB_SHA: ${{ github.sha }}                      # Git commit SHA for traceability
  IBMCLOUD_API_KEY: ${{ secrets.IBMCLOUD_API_KEY }}  # IBM Cloud authentication
  IBMCLOUD_REGION: ${{ vars.IBMCLOUD_REGION }}       # IBM Cloud region (e.g., us-south)
  ICR_NAMESPACE: ${{ vars.ICR_NAMESPACE }}           # Container Registry namespace
  RESOURCE_GROUP: ${{ vars.RESOURCE_GROUP }}         # IBM Cloud resource group
  REGISTRY_HOSTNAME: ${{ vars.ICR_REGION }}          # ICR hostname (e.g., us.icr.io)
  IMAGE_NAME: ${{ vars.IMAGE_NAME }}                 # Base container image name
  PROJECT_NAME: ${{ vars.PROJECT_NAME }}             # Code Engine project name
  APP_NAME: ${{ vars.APP_NAME }}                     # Code Engine application name

jobs:

  # Main CI/CD pipeline job - builds, tests, and deploys the application
  ci-pipeline:
    name: CI Pipeline
    runs-on: ubuntu-latest      # Use latest Ubuntu runner
    environment: production     # Uses production environment settings and protection rules
    steps:

    # Step 1: Checkout the repository code
    # Uses GitHub's official checkout action to clone the repository
    - id: checkout-ci-code
      name: Checkout CI code
      uses: actions/checkout@v4
  
    # Step 2: Run unit tests
    # Installs dependencies and executes unit tests to validate code quality
    # Fails the workflow if tests don't pass
    - id: unit-test-ci-code
      name: Unit test CI code
      run: |
        npm install          # Install all npm dependencies
        npm run test-unit    # Run unit tests (must be defined in package.json)

    - id: login-ibmcloud-cli
      name: Login IBM Cloud CLI
      uses: IBM/actions-ibmcloud-cli@v1
      if: ${{ success() }}
      with:
        api_key: ${{ secrets.IBMCLOUD_API_KEY }} 
        region: ${{ vars.IBMCLOUD_REGION }} 
        group: ${{ vars.RESOURCE_GROUP }} 
        plugins: "code-engine, container-registry"

    # Step 5: Get currently deployed image digest from ICR
    # Retrieves the SHA256 digest of the "latest" tagged image
    # This digest uniquely identifies the exact image version and is exposed as an output
    # for use in subsequent steps or workflows (e.g., deployment verification, rollback)
    - id: get-currently-deployed-image-digest
      name: Get currently deployed image digest
      if: ${{ success() }}
      run: |
        # Install IBM Cloud CLI if not already available
        # if ! command -v ibmcloud &> /dev/null; then
        #  curl -fsSL https://clis.cloud.ibm.com/install/linux | sh
        # fi
        
        # Login to IBM Cloud
        # ibmcloud login --apikey ${{ secrets.IBMCLOUD_API_KEY }} -r ${{ vars.IBMCLOUD_REGION }} -g ${{ vars.RESOURCE_GROUP }}
        
        # Get the digest of the latest image from ICR
        IMAGE_PATH="private.${{ vars.ICR_REGION }}/${{ vars.ICR_NAMESPACE }}/ci-${{ vars.IMAGE_NAME }}:latest"
        DIGEST=$(ibmcloud cr image-inspect $IMAGE_PATH --format '{{.RepoDigests}}' | grep -oP 'sha256:[a-f0-9]{64}')
        
        echo "Currently deployed "latest" image digest: $DIGEST"
        
        # Export the digest as a step output for use in other steps
        echo "currently-deployed-image-digest=$DIGEST" >> $GITHUB_OUTPUT

    # Step 3: Build container image using Code Engine
    # Uses IBM's Code Engine GitHub Action to build the Docker image
    # Image is pushed to private IBM Container Registry
    - id: build-ci-image
      name: Build CI image using Code Engine
      uses: IBM/code-engine-github-action@v1
      if: ${{ success() }}
      with:
        api-key: ${{ secrets.IBMCLOUD_API_KEY }}                    # IBM Cloud API key for authentication
        resource-group: ${{ vars.RESOURCE_GROUP }}                  # Target resource group
        region: ${{ vars.IBMCLOUD_REGION }}                         # IBM Cloud region
        project: ${{ vars.PROJECT_NAME }}                           # Code Engine project name
        component: 'build'                                          # Specifies this is a build operation
        name: 'build-ci-image'                                      # Name for the build configuration
        image: "private.${{ vars.ICR_REGION }}/${{ vars.ICR_NAMESPACE }}/ci-${{ vars.IMAGE_NAME }}:latest"  # Full image path in ICR
        registry-secret: "ce-auto-icr-private-${{ vars.IBMCLOUD_REGION }}"  # Auto-generated registry secret
        build-source: './' # Build context (current directory)

    # Step 4: Scan container image for vulnerabilities
    # TODO: Implement actual vulnerability scanning (e.g., Trivy, IBM Vulnerability Advisor)
    # Currently a placeholder that outputs the image digest
    - id: scan-icr-ci-image
      name: Scan ICR CI image
      if: ${{ success() }}
      run: |
        echo "Scan ICR CI image with digest: ${{ steps.build-ci-image.outputs.image-with-digest }} <todo>"
        IMAGE_PATH="private.${{ vars.ICR_REGION }}/${{ vars.ICR_NAMESPACE }}/ci-${{ vars.IMAGE_NAME }}:latest"
        DIGEST=$(ibmcloud cr image-inspect $IMAGE_PATH --format '{{.RepoDigests}}' | grep -oP 'sha256:[a-f0-9]{64}')
    
    # Step 6: Deploy application to Code Engine
    # Uses IBM's Code Engine GitHub Action to deploy or update the application
    # Configures the app with 1 CPU and 4GB memory
    - id: deploy-ci-app-to-code-engine
      name: Deploy CI application to Code Engine
      uses: IBM/code-engine-github-action@v1
      if: ${{ success() }}
      with:
        api-key: ${{ secrets.IBMCLOUD_API_KEY }}                    # IBM Cloud API key for authentication
        resource-group: ${{ vars.RESOURCE_GROUP }}                  # Target resource group
        region: ${{ vars.IBMCLOUD_REGION }}                         # IBM Cloud region
        project: ${{ vars.PROJECT_NAME }}                           # Code Engine project name
        name: ${{ vars.APP_NAME }}                                  # Application name in Code Engine
        component: 'app'                                            # Specifies this is an app deployment
        image: "private.${{ vars.ICR_REGION }}/${{ vars.ICR_NAMESPACE }}/ci-${{ vars.IMAGE_NAME }}:latest"  # Image to deploy
        registry-secret: "ce-auto-icr-private-${{ vars.IBMCLOUD_REGION }}"  # Registry authentication
        cpu: 1                                                      # Allocate 1 vCPU
        memory: 4G                                                  # Allocate 4GB memory

    # Step 6: Run integration tests against deployed application
    # Retrieves the deployed app URL and runs integration tests
    # TODO: Uncomment and implement actual integration tests
    - id: run-integration-tests
      name: Run Integration Tests
      if: ${{ success() }}
      run: |
        # Get the deployed application URL from Code Engine
        APP_URL=$(ibmcloud ce app get --name ${{ vars.APP_NAME }} --output json | jq -r '.status.url')
        
        echo "Running Integration tests against: ${APP_URL}"
        echo

        # TODO: Uncomment when integration tests are ready
        #npm run test-integration -- --url=$APP_URL

    # Step 7: Rollback on failure
    # If any previous step fails, attempt to rollback to the previous image
    # Only runs if the workflow fails (if: failure() condition)
    # TODO: Set PREVIOUS_IMAGE environment variable before deployment
    - id: rollback-on-failure
      name: Rollback on failure
      if: ${{ failure() }}  # Only runs if any previous step failed
      run: |
        # Rollback to previous image version
        ibmcloud ce app update --name ${{ vars.APP_NAME }} \
          --image ${{ steps.get-currently-deployed-image-digest.outputs.currently-deployed-image-digest }}
